import { useCallback, useState } from "react";
import { Socket } from "socket.io-client";
import { WebRTCManager, createWebRTCManager } from "@/lib/webrtc";
import { useUser } from "@/app/providers/UserProvider";

interface CallState {
  isInCall: boolean;
  callId: string | null;
  roomId: string | null;
  callType: "audio" | "video" | null;
  chatType: "DMs" | "Groups" | null;
  isConnecting: boolean;
  isConnected: boolean;
  error: string | null;
}

interface UseCallManagerReturn {
  callState: CallState;
  initiateCall: (callData: {
    roomId: string;
    targetUserId?: string;
    callType: "audio" | "video";
    chatType: "DMs" | "Groups";
  }) => Promise<void>;
  answerCall: (
    callId: string,
    accepted: boolean,
    callData?: {
      roomId: string;
      callType: "audio" | "video";
      chatType: "DMs" | "Groups";
    }
  ) => Promise<void>;
  endCall: () => Promise<void>;
  setError: (error: string | null) => void;
  clearError: () => void;
  getWebRTCManager: () => WebRTCManager | null;
}

export function useCallManager(socket: Socket): UseCallManagerReturn {
  const { userdata } = useUser();
  const [callState, setCallState] = useState<CallState>({
    isInCall: false,
    callId: null,
    roomId: null,
    callType: null,
    chatType: null,
    isConnecting: false,
    isConnected: false,
    error: null,
  });

  const [webrtcManager, setWebRTCManager] = useState<WebRTCManager | null>(null);

  const updateCallState = useCallback((updates: Partial<CallState>) => {
    setCallState((prev) => ({ ...prev, ...updates }));
  }, []);

  const setError = useCallback(
    (error: string | null) => {
      updateCallState({ error });
    },
    [updateCallState]
  );

  const clearError = useCallback(() => {
    updateCallState({ error: null });
  }, [updateCallState]);

  const getWebRTCManager = useCallback(() => {
    return webrtcManager;
  }, [webrtcManager]);

  const initiateCall = useCallback(
    async (callData: {
      roomId: string;
      targetUserId?: string;
      callType: "audio" | "video";
      chatType: "DMs" | "Groups";
    }) => {
      try {
        // Initialize WebRTC manager
        const manager = createWebRTCManager(socket);
        setWebRTCManager(manager);

        // Update call state
        updateCallState({
          isInCall: true,
          roomId: callData.roomId,
          callType: callData.callType,
          chatType: callData.chatType,
          isConnecting: true,
          isConnected: false,
          error: null,
        });

        // Set up call state change handler
        manager.setOnCallStateChange((state) => {
          switch (state) {
            case "connecting":
              updateCallState({ isConnecting: true, isConnected: false });
              break;
            case "connected":
              updateCallState({ isConnecting: false, isConnected: true });
              break;
            case "ended":
            case "declined":
              updateCallState({
                isInCall: false,
                callId: null,
                roomId: null,
                callType: null,
                chatType: null,
                isConnecting: false,
                isConnected: false,
              });
              break;
          }
        });

        // Initiate the call
        const callId = await manager.initiateCall({
          callId: "", // Will be generated by server
          roomId: callData.roomId,
          callerId: userdata?._id?.toString() || "",
          targetUserId: callData.targetUserId,
          callType: callData.callType,
          chatType: callData.chatType,
        });

        updateCallState({ callId });

        // Set up peer connection
        await manager.setupPeerConnection(callData.callType);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "Failed to initiate call";
        setError(errorMessage);
        updateCallState({
          isInCall: false,
          callId: null,
          roomId: null,
          callType: null,
          chatType: null,
          isConnecting: false,
          isConnected: false,
        });
      }
    },
    [socket, updateCallState, setError, userdata?._id]
  );

  const answerCall = useCallback(
    async (
      callId: string,
      accepted: boolean,
      callData?: {
        roomId: string;
        callType: "audio" | "video";
        chatType: "DMs" | "Groups";
      }
    ) => {
      if (!webrtcManager) return;

      try {
        if (accepted) {
          // Initialize WebRTC manager if not already done
          if (!webrtcManager) {
            const manager = createWebRTCManager(socket);
            setWebRTCManager(manager);
          }

          updateCallState({
            isInCall: true,
            callId,
            roomId: callData?.roomId || null,
            callType: callData?.callType || "audio",
            chatType: callData?.chatType || "DMs",
            isConnecting: true,
            isConnected: false,
            error: null,
          });

          // Set up peer connection
          await webrtcManager.setupPeerConnection(callData?.callType || "audio");
        }

        // Answer the call
        await webrtcManager.answerCall(callId, accepted);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "Failed to answer call";
        setError(errorMessage);
        updateCallState({
          isInCall: false,
          callId: null,
          roomId: null,
          callType: null,
          chatType: null,
          isConnecting: false,
          isConnected: false,
        });
      }
    },
    [webrtcManager, socket, updateCallState, setError]
  );

  const endCall = useCallback(async () => {
    if (webrtcManager) {
      try {
        await webrtcManager.endCall();
      } catch (error) {
        console.error("Error ending call:", error);
      }
    }

    // Clean up
    setWebRTCManager(null);
    updateCallState({
      isInCall: false,
      callId: null,
      roomId: null,
      callType: null,
      chatType: null,
      isConnecting: false,
      isConnected: false,
    });
  }, [webrtcManager, updateCallState]);

  return {
    callState,
    initiateCall,
    answerCall,
    endCall,
    setError,
    clearError,
    getWebRTCManager,
  };
}
