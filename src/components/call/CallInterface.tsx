"use client";

import React, { useEffect, useRef, useState } from "react";
import { useUser } from "@/app/providers/UserProvider";
import { WebRTCManager, createWebRTCManager } from "@/lib/webrtc";
import { Socket } from "socket.io-client";
import CallControls from "./CallControls";
import CallStatus from "./CallStatus";

interface CallInterfaceProps {
  socket: Socket;
  roomId: string;
  targetUserId?: string;
  chatType: "DM" | "Group";
  onCallEnd?: () => void;
}

export default function CallInterface({
  socket,
  roomId,
  targetUserId,
  chatType,
  onCallEnd,
}: CallInterfaceProps) {
  const { userdata } = useUser();
  const [callState, setCallState] = useState<
    "idle" | "connecting" | "connected" | "ended" | "declined"
  >("idle");
  const [callType, setCallType] = useState<"audio" | "video">("audio");
  const [isMuted, setIsMuted] = useState(false);
  const [isVideoEnabled, setIsVideoEnabled] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const localVideoRef = useRef<HTMLVideoElement>(null);
  const remoteVideoRef = useRef<HTMLVideoElement>(null);
  const webrtcManagerRef = useRef<WebRTCManager | null>(null);

  useEffect(() => {
    // Initialize WebRTC manager
    webrtcManagerRef.current = createWebRTCManager(socket);

    // Set up call state change handler
    webrtcManagerRef.current.setOnCallStateChange((state) => {
      setCallState(state as any);
      if (state === "ended" || state === "declined") {
        onCallEnd?.();
      }
    });

    // Set up remote stream handler
    webrtcManagerRef.current.setOnRemoteStream((stream) => {
      if (remoteVideoRef.current) {
        remoteVideoRef.current.srcObject = stream;
      }
    });

    return () => {
      webrtcManagerRef.current?.destroy();
    };
  }, [socket, onCallEnd]);

  const initiateCall = async (type: "audio" | "video") => {
    if (!webrtcManagerRef.current) return;

    try {
      setCallState("connecting");
      setCallType(type);
      setError(null);

      // Initiate the call
      const callId = await webrtcManagerRef.current.initiateCall({
        callId: "", // Will be generated by server
        roomId,
        callerId: userdata?._id?.toString() || "",
        callType: type,
        chatType,
      });

      // Set up peer connection
      await webrtcManagerRef.current.setupPeerConnection(type);

      // Set local video stream
      const localStream = webrtcManagerRef.current.getLocalStream();
      if (localStream && localVideoRef.current) {
        localVideoRef.current.srcObject = localStream;
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to initiate call");
      setCallState("idle");
    }
  };

  const answerCall = async (accepted: boolean) => {
    if (!webrtcManagerRef.current) return;

    try {
      if (accepted) {
        setCallState("connecting");
        setError(null);

        // Set up peer connection
        await webrtcManagerRef.current.setupPeerConnection(callType);

        // Set local video stream
        const localStream = webrtcManagerRef.current.getLocalStream();
        if (localStream && localVideoRef.current) {
          localVideoRef.current.srcObject = localStream;
        }
      }

      // Answer the call
      await webrtcManagerRef.current.answerCall("", accepted); // callId will be set by the manager
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to answer call");
      setCallState("idle");
    }
  };

  const endCall = async () => {
    if (!webrtcManagerRef.current) return;

    try {
      await webrtcManagerRef.current.endCall();
      setCallState("ended");
      onCallEnd?.();
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to end call");
    }
  };

  const toggleMute = () => {
    if (webrtcManagerRef.current?.getLocalStream()) {
      const audioTrack = webrtcManagerRef.current.getLocalStream()?.getAudioTracks()[0];
      if (audioTrack) {
        audioTrack.enabled = !audioTrack.enabled;
        setIsMuted(!audioTrack.enabled);
      }
    }
  };

  const toggleVideo = () => {
    if (webrtcManagerRef.current?.getLocalStream()) {
      const videoTrack = webrtcManagerRef.current.getLocalStream()?.getVideoTracks()[0];
      if (videoTrack) {
        videoTrack.enabled = !videoTrack.enabled;
        setIsVideoEnabled(videoTrack.enabled);
      }
    }
  };

  const handleIncomingCall = (data: any) => {
    // This will be handled by the IncomingCall component
    // We just need to update our state
    setCallType(data.callType);
    setCallState("connecting");
  };

  useEffect(() => {
    // Listen for incoming call events
    socket.on("call:invite", handleIncomingCall);

    return () => {
      socket.off("call:invite", handleIncomingCall);
    };
  }, [socket]);

  if (error) {
    return (
      <div className="flex flex-col items-center justify-center p-6 bg-red-50 rounded-lg">
        <div className="text-red-600 text-lg font-semibold mb-2">Call Error</div>
        <div className="text-red-500 text-center mb-4">{error}</div>
        <button
          onClick={() => {
            setError(null);
            setCallState("idle");
          }}
          className="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors"
        >
          Dismiss
        </button>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full bg-gray-900 text-white">
      {/* Call Status */}
      <CallStatus state={callState} callType={callType} roomId={roomId} />

      {/* Video Container */}
      <div className="flex-1 relative overflow-hidden">
        {/* Remote Video */}
        {callState === "connected" && (
          <video ref={remoteVideoRef} autoPlay playsInline className="w-full h-full object-cover" />
        )}

        {/* Local Video */}
        {callType === "video" && callState !== "idle" && (
          <div className="absolute top-4 right-4 w-32 h-24 bg-gray-800 rounded-lg overflow-hidden">
            <video
              ref={localVideoRef}
              autoPlay
              playsInline
              muted
              className="w-full h-full object-cover"
            />
          </div>
        )}

        {/* Call Controls Overlay */}
        {callState === "connected" && (
          <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2">
            <CallControls
              isMuted={isMuted}
              isVideoEnabled={isVideoEnabled}
              onToggleMute={toggleMute}
              onToggleVideo={toggleVideo}
              onEndCall={endCall}
            />
          </div>
        )}
      </div>

      {/* Call Actions */}
      {callState === "idle" && (
        <div className="p-6 bg-gray-800">
          <div className="flex flex-col space-y-4">
            <button
              onClick={() => initiateCall("audio")}
              className="px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors flex items-center justify-center space-x-2"
            >
              <span>ðŸ“ž</span>
              <span>Audio Call</span>
            </button>

            {chatType === "DM" && (
              <button
                onClick={() => initiateCall("video")}
                className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors flex items-center justify-center space-x-2"
              >
                <span>ðŸ“¹</span>
                <span>Video Call</span>
              </button>
            )}
          </div>
        </div>
      )}

      {/* Connecting State */}
      {callState === "connecting" && (
        <div className="p-6 bg-gray-800">
          <div className="flex flex-col items-center space-y-4">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-white"></div>
            <div className="text-center">
              <div className="text-lg font-semibold">Connecting...</div>
              <div className="text-gray-400">Setting up your call</div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
